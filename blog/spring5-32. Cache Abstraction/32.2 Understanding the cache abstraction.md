#3.2.2 Understanding the cache abstraction

Cache vs Buffer

The terms "buffer" and "cache" tend to be used interchangeably; note however they represent different things. A buffer is used traditionally as an intermediate temporary store for data between a fast and a slow entity. As one party would have to wait for the other affecting performance, the buffer alleviates this by allowing entire blocks of data to move at once rather then in small chunks. The data is written and read only once from the buffer. Furthermore, the buffers are visible to at least one party which is aware of it.

A cache on the other hand by definition is hidden and neither party is aware that caching occurs.It as well improves performance but does that by allowing the same data to be read multiple times in a fast fashion.

A further explanation of the differences between two can be found here.

## 缓存抽象

```
缓存（Cache） vs 缓冲区（Buffer）

缓存和缓冲区两个术语往往可以互换着使用。但注意，它们代表着不同的东西。缓冲区是作用于快和慢速实体之间的中间临时存储。一块缓冲区必须等待其他并影响性能，通过允许一次性移动整个数据块而不是小块来缓解。数据从缓冲区读写只有一次。因此缓冲区对至少一方是可见的。

另一方面，缓存根据定义是隐性的，双方不会知道缓存的发生。它提高了性能，但允许以快速的方式多次读取相同的数据。

更多差异解释见 

https://en.wikipedia.org/wiki/Cache_(computing)#The_difference_between_buffer_and_cache

```

At its core, the abstraction applies caching to Java methods, reducing thus the number of executions based on the information available in the cache. That is, each time a targeted method is invoked, the abstraction will apply a caching behavior checking whether the method has been already executed for the given arguments. If it has, then the cached result is returned without having to execute the actual method; if it has not, then method is executed, the result cached and returned to the user so that, the next time the method is invoked, the cached result is returned. This way, expensive methods (whether CPU or IO bound) can be executed only once for a given set of parameters and the result reused without having to actually execute the method again. The caching logic is applied transparently without any interference to the invoker.

核心上，抽象将缓存作用于 Java 方法上，可以减少基于缓存中的可用信息的执行次数。也就是说，每次目标方法的调用时，抽象使用缓存行为来检查执行方法，检查执行方法是否给定了缓存的执行参数。如果有，则返回缓存结果，不执行具体实际方法；如果没有，则执行方法，并将结果缓存后，返回结果给用户。以便于下次调用方法时，直接返回缓存的结果。这样，只要给定缓存执行参数，在复杂的方法（无论是 CPU 或者 IO 相关）只需要执行一次，就可以得到结果，并利用缓存可重复使用结果，而不必再次执行该方法。另外，缓存逻辑可以被透明地调用，不会对调用者造成任何的困扰。

Important
Obviously this approach works only for methods that are guaranteed to return the same output (result) for a given input (or arguments) no matter how many times it is being executed.

```
重点
显然，只适用于无论执行多少次都是某个给定输入（或参数）返回相同的输出（结果）的方法。
```

Other cache-related operations are provided by the abstraction such as the ability to update the content of the cache or remove one of all entries. These are useful if the cache deals with data that can change during the course of the application.

Just like other services in the Spring Framework, the caching service is an abstraction (not a cache implementation) and requires the use of an actual storage to store the cache data - that is, the abstraction frees the developer from having to write the caching logic but does not provide the actual stores. This abstraction is materialized by the `org.springframework.cache.Cache` and `org.springframework.cache.CacheManager` interfaces.

There are a few implementations of that abstraction available out of the box: JDK `java.util.concurrent.ConcurrentMap` based caches, Ehcache 2.x, Gemfire cache, Caffeine and JSR-107 compliant caches (e.g. Ehcache 3.x). See Section 32.7, “Plugging-in different back-end caches” for more information on plugging in other cache stores/providers.

抽象提供的其他缓存相关操作，比如更新缓存内容或者删除其中一条缓存。如果在应用程序过程中，发生了变化的数据需要缓存，那这些功能会很有用。

比如 Spring 框架其他服务一样，缓存服务是一种抽象（不是缓存的实现），并且需要使用实际的存储器来存储缓存数据。也就是说，抽象使开发人员不必编写缓存逻辑，但不提供缓存的存储器。这个抽象是由 `org.springframework.cache.Cache` 和 `org.springframework.cache.CacheManager` 接口实现的。

有些抽象的实现是开箱即用的：基于 JDK `java.util.concurrent.ConcurrentMap` 缓存实现，Ehcache 2.x，Gemfire cache, Caffeine 和 JSR-107 缓存（例如 Ehcache 3.x）。有关缓存存储/提供的更多信息，请参见 32.7 节 《Plugging-in different back-end caches》。

Important
The caching abstraction has no special handling of multi-threaded and multi-process environments as such features are handled by the cache implementation. .

If you have a multi-process environment (i.e. an application deployed on several nodes), you will need to configure your cache provider accordingly. Depending on your use cases, a copy of the same data on several nodes may be enough but if you change the data during the course of the application, you may need to enable other propagation mechanisms.

Caching a particular item is a direct equivalent of the typical get-if-not-found-then- proceed-and-put-eventually code blocks found with programmatic cache interaction: no locks are applied and several threads may try to load the same item concurrently. The same applies to eviction: if several threads are trying to update or evict data concurrently, you may use stale data. Certain cache providers offer advanced features in that area, refer to the documentation of the cache provider that you are using for more details.

To use the cache abstraction, the developer needs to take care of two aspects:

- caching declaration - identify the methods that need to be cached and their policy
- cache configuration - the backing cache where the data is stored and read from


```
重点
缓存抽象没有特别处理多线程和多进程环境，因为这些功能由缓存实现来处理...
```

如果是多进程环境（即部署在多个节点上的应用程序），则需要相应的配置程序提供缓存。根据使用情况，几个节点上相同数据的副本可能足够多了，但如果在应用程序过程中更改了数据，则需要启动其他传播机制，进行同步缓存数据。

缓存一个特定的对象是典型的缓存交互 get-if-not-found-then-proceed-and-put-finally 代码块：不需应用任何锁，并且几个线程同时尝试加载相同的对象。同样适用于回收，如果多个线程同时更新或者回收数据，则可能会使用过时的数据。某些缓存提供者在该领域提供高级功能，请参考您正在使用的缓存提供程序的更多高级功能详细信息。

要使用缓存抽象，开发人员需要注意两个方面：

- 缓存声明 - 标志缓存的方法及缓存策略
- 缓存配置 - 数据存储和读取的缓存数据库
