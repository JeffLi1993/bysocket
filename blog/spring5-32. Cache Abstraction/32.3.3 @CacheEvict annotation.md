### 32.3.3 @CacheEvict 注解
缓存抽象不仅仅缓存更多数据，而且可以缓存收回。这个过程对于从缓存中删除旧或者未使用的数据非常有用。不建议使用 `@Cacheable` ,注解 `@CacheEvict` 划分了缓存收回的方法，即作为从缓存中删除数据的触发器方法。`@CacheEvict` 需要指定一个（或者多个）执行动作，并且允许自定义缓存和键解析或条件被指定。但有一个额外的参数 `allEntries`,可以指示是否所有条目都要被收回，还是一个条目（基于键）。

```
@CacheEvict(cacheNames="books", allEntries=true)
public void loadBooks(InputStream batch)
```

当整个缓存区需要被收回时，这个选项就会派上用场 - 而不是回收每个条目（当不起作用时会需要很长的响应时间），所有条目会在一个操作中被删除。注意框架将忽略此场景下指定的任何键，因为它不是用（整个缓存收回，不仅仅是一个条目被收回）。

还可以指出发生缓存回收是在默认之后还是在通过 `beforeInvocation` 属性执行方法后。前者提供与其他注解相同的语义 - 一旦方法成功完成，就执行缓存上的动作（这种情况是回收）。如果方法不执行（因为它可能会被缓存）或者抛出异常，则不会发生回收。后者（`beforeInvocation = ture`）会导致在调用该方法之前发生回收 - 这在回收但不需要绑定到方法结果的情况下是有用的。

重要的是，`void` 方法可以和 `@CacheEvict` 一起使用 - 由于方法作为触发器，返回值会被忽略（因为他们不与缓存交互） - `@Cacheable` 就不是这样的，它添加 / 更新数据到缓存时，需要一个结果。
